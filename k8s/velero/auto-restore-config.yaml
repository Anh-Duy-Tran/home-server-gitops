apiVersion: v1
kind: Namespace
metadata:
  name: velero
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: velero-restore-job
  namespace: velero
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: velero-restore-job
  namespace: velero
rules:
  - apiGroups: ["velero.io"]
    resources: ["backups", "restores"]
    verbs: ["get", "list", "create"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: velero-restore-job
  namespace: velero
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: velero-restore-job
subjects:
  - kind: ServiceAccount
    name: velero-restore-job
    namespace: velero
---
apiVersion: batch/v1
kind: Job
metadata:
  name: velero-auto-restore
  namespace: velero
spec:
  template:
    spec:
      serviceAccountName: velero-restore-job
      initContainers:
        - name: wait-for-velero
          image: bitnami/kubectl:latest
          command:
            - /bin/bash
            - -c
            - |
              set -e
              echo "Waiting for Velero deployment to exist..."

              # Wait for velero deployment to exist (up to 5 minutes)
              for i in {1..60}; do
                if kubectl get deployment velero -n velero >/dev/null 2>&1; then
                  echo "Velero deployment found!"
                  break
                fi
                echo "Waiting for Velero deployment to be created... ($i/60)"
                sleep 5
              done

              # Verify deployment exists
              if ! kubectl get deployment velero -n velero >/dev/null 2>&1; then
                echo "ERROR: Velero deployment not found after 5 minutes"
                exit 1
              fi

              echo "Waiting for Velero deployment to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/velero -n velero

              echo "Waiting for Velero pods to be running..."
              kubectl wait --for=condition=ready --timeout=60s pod -l app.kubernetes.io/name=velero -n velero

              echo "Velero is ready!"
      containers:
        - name: restore
          image: bitnami/kubectl:latest
          command:
            - /bin/bash
            - -c
            - |
              set -e
              echo "Fetching latest backup..."

              # Get the latest backup name using kubectl
              LATEST=$(kubectl get backups.velero.io -n velero -o json | \
                jq -r '.items | sort_by(.status.completionTimestamp) | last | .metadata.name')

              if [ -z "$LATEST" ] || [ "$LATEST" = "null" ]; then
                echo "No backups found!"
                exit 1
              fi

              echo "Creating restore from backup: $LATEST"

              # Create a restore resource (include pods to restore volume data)
              RESTORE_NAME="auto-restore-$(date +%s)"
              cat <<EOF | kubectl apply -f -
              apiVersion: velero.io/v1
              kind: Restore
              metadata:
                name: $RESTORE_NAME
                namespace: velero
              spec:
                backupName: $LATEST
                includedNamespaces:
                - '*'
              EOF

              echo "Waiting for restore to complete..."
              kubectl wait --for=condition=complete restore/$RESTORE_NAME -n velero --timeout=10m || true

              echo "Waiting for volume restores to complete..."
              kubectl wait --for=jsonpath='{.status.phase}'=Completed podvolumerestore -n velero --all --timeout=10m || true

              echo "Restore completed! PVCs restored with data. ArgoCD will recreate apps."
      restartPolicy: OnFailure
  backoffLimit: 3
